class IDDB_Wrapper{#a;#b=null;#c=new Map;#d=null;constructor(e){if(!e||"string"!=typeof e||""===e.trim())throw Error("Database name is required and must be a non-empty string.");this.#a=e}async #e(e){if(this.#c.has(e))return this.#c.get(e);let t=await this.#f(e),r={set:(r,s)=>this.#g(t,e,r,s),get:r=>this.#h(t,e,r),delete:r=>this.#i(t,e,r),getAll:()=>this.#j(t,e),clear:()=>this.#k(t,e)};return this.#c.set(e,r),r}async #f(s){return this.#b&&this.#d===s?this.#b:(this.#b&&(this.#b.close(),this.#b=null,this.#d=null),new Promise((e,t)=>{let r=indexedDB.open(this.#a);r.onupgradeneeded=e=>{let t=e.target.result;t.objectStoreNames.contains(s)||t.createObjectStore(s,{autoIncrement:!0})},r.onsuccess=()=>{let n=r.result;if(this.#b=n,this.#d=s,n.objectStoreNames.contains(s))e(n);else{n.close();let a=indexedDB.open(this.#a,n.version+1);a.onupgradeneeded=e=>{let t=e.target.result;t.createObjectStore(s,{autoIncrement:!0})},a.onsuccess=()=>{this.#b=a.result,this.#d=s,e(this.#b)},a.onerror=t}},r.onerror=t}))}async #g(n,a,o,l){return new Promise((e,t)=>{let r=n.transaction(a,"readwrite").objectStore(a),s="auto"===o||null==o||""===o?r.add(l):r.put(l,o);s.onsuccess=()=>e(s.result),s.onerror=t})}async #h(i,c,u){return new Promise((e,t)=>{let r=i.transaction(c).objectStore(c),s=r.get(u);s.onsuccess=()=>{let t=s.result;void 0!==t?e(t):e(void 0)},s.onerror=t})}async #j(b,h){return new Promise((e,t)=>{let r=b.transaction(h).objectStore(h),s=[],n=r.openCursor();n.onsuccess=t=>{let r=t.target.result;r?(s.push({key:r.key,value:r.value}),r.continue()):e(s)},n.onerror=t})}async #i(d,p,w){return new Promise((e,t)=>{let r=d.transaction(p,"readwrite").objectStore(p),s=r.delete(w);s.onsuccess=()=>e(!0),s.onerror=t})}async #k(y,g){return new Promise((e,t)=>{let r=y.transaction(g,"readwrite").objectStore(g),s=r.clear();s.onsuccess=()=>e(!0),s.onerror=t})}use(e){return{set:async(t,r)=>{let s=await this.#e(e);return s.set(t,r)},get:async t=>{let r=await this.#e(e);return r.get(t)},delete:async t=>{let r=await this.#e(e);return r.delete(t)},getAll:async()=>{let t=await this.#e(e);return t.getAll()},clear:async()=>{let t=await this.#e(e);return t.clear()}}}async drop(e){return this.#b||await this.#f(e),this.#b.close(),new Promise((t,r)=>{let s=indexedDB.open(this.#a,this.#b.version+1);s.onupgradeneeded=t=>{let r=t.target.result;r.objectStoreNames.contains(e)&&r.deleteObjectStore(e)},s.onsuccess=()=>{this.#b=s.result,this.#c.delete(e),t()},s.onerror=r})}async export(e){let{filename:t="db_backup",download:r=!0}=e??{},s={},n=indexedDB.open(this.#a),a=await new Promise((e,t)=>{n.onsuccess=()=>e(n.result),n.onerror=t}),o=Array.from(a.objectStoreNames);for(let l of o){let i=await new Promise((e,t)=>{let r=a.transaction(l,"readonly"),s=r.objectStore(l),n=[],o=s.openCursor();o.onsuccess=t=>{let r=t.target.result;r?(n.push({key:r.key,value:r.value}),r.continue()):e(n)},o.onerror=t});s[l]=i}a.close();let c=JSON.stringify(s,null,2);if(r){let u=new Blob([c],{type:"application/json"}),b=document.createElement("a");b.href=URL.createObjectURL(u),b.download=t+".json",b.click(),setTimeout(()=>{URL.revokeObjectURL(b.href)},1e3);return}return c}async import(e){let t;try{t=JSON.parse(e)}catch(r){throw Error("Invalid JSON format")}for(let s in t){let n=await this.#f(s);await this.#k(n,s);let a=n.transaction(s,"readwrite"),o=a.objectStore(s);for(let{key:l,value:i}of t[s])o.put(i,l);await new Promise((e,t)=>{a.oncomplete=e,a.onerror=t}),n.close(),this.#b=null}}}