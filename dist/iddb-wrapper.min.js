class IDDB_Wrapper{#a;#b=null;#c=new Map;#d=null;constructor(e){if(!e||"string"!=typeof e||""===e.trim())throw Error("Database name is required and must be a non-empty string.");this.#a=e}async #e(e){if(this.#c.has(e))return this.#c.get(e);let t=await this.#f(e),s={set:(s,r)=>this.#g(t,e,s,r),get:s=>this.#h(t,e,s),delete:s=>this.#i(t,e,s),getAll:()=>this.#j(t,e),clear:()=>this.#k(t,e)};return this.#c.set(e,s),s}async #f(r){return this.#b&&this.#d===r?this.#b:(this.#b&&(this.#b.close(),this.#b=null,this.#d=null),new Promise((e,t)=>{let s=indexedDB.open(this.#a);s.onupgradeneeded=e=>{let t=e.target.result;t.objectStoreNames.contains(r)||t.createObjectStore(r,{autoIncrement:!0})},s.onsuccess=()=>{let n=s.result;if(this.#b=n,this.#d=r,n.objectStoreNames.contains(r))e(n);else{n.close();let a=indexedDB.open(this.#a,n.version+1);a.onupgradeneeded=e=>{let t=e.target.result;t.createObjectStore(r,{autoIncrement:!0})},a.onsuccess=()=>{this.#b=a.result,this.#d=r,e(this.#b)},a.onerror=t}},s.onerror=t}))}async #g(n,a,o,l){return new Promise((e,t)=>{let s=n.transaction(a,"readwrite").objectStore(a),r="auto"===o||null==o||""===o?s.add(l):s.put(l,o);r.onsuccess=()=>e(r.result),r.onerror=t})}async #h(i,c,u){return new Promise((e,t)=>{let s=i.transaction(c).objectStore(c),r=s.get(u);r.onsuccess=()=>{let t=r.result;void 0!==t?e(t):e(void 0)},r.onerror=t})}async #j(b,d){return new Promise((e,t)=>{let s=b.transaction(d).objectStore(d),r=[],n=s.openCursor();n.onsuccess=t=>{let s=t.target.result;s?(r.push({key:s.key,value:s.value}),s.continue()):e(r)},n.onerror=t})}async #i(h,p,g){return new Promise((e,t)=>{let s=h.transaction(p,"readwrite").objectStore(p),r=s.delete(g);r.onsuccess=()=>e(!0),r.onerror=t})}async #k(w,y){return new Promise((e,t)=>{let s=w.transaction(y,"readwrite").objectStore(y),r=s.clear();r.onsuccess=()=>e(!0),r.onerror=t})}use(e){return{set:async(t,s)=>{let r=await this.#e(e);return r.set(t,s)},get:async t=>{let s=await this.#e(e);return s.get(t)},delete:async t=>{let s=await this.#e(e);return s.delete(t)},getAll:async()=>{let t=await this.#e(e);return t.getAll()},clear:async()=>{let t=await this.#e(e);return t.clear()}}}async drop(e){return this.#b||await this.#f(e),this.#b.close(),new Promise((t,s)=>{let r=indexedDB.open(this.#a,this.#b.version+1);r.onupgradeneeded=t=>{let s=t.target.result;s.objectStoreNames.contains(e)&&s.deleteObjectStore(e)},r.onsuccess=()=>{this.#b=r.result,this.#c.delete(e),t()},r.onerror=s})}}