class IDDB_Wrapper{#a;#b=null;#c=new Map;#d=null;constructor(e){if(!e||"string"!=typeof e||""===e.trim())throw Error("Database name is required and must be a non-empty string.");this.#a=e}async #e(e){if(this.#c.has(e))return this.#c.get(e);let t=await this.#f(e),r={set:(r,s)=>this.#g(t,e,r,s),get:r=>this.#h(t,e,r),delete:r=>this.#i(t,e,r),getAll:()=>this.#j(t,e),clear:()=>this.#k(t,e)};return this.#c.set(e,r),r}async #f(s){return this.#b&&this.#d===s?this.#b:(this.#b&&(this.#b.close(),this.#b=null,this.#d=null),new Promise((e,t)=>{let r=indexedDB.open(this.#a);r.onupgradeneeded=e=>{let t=e.target.result;t.objectStoreNames.contains(s)||t.createObjectStore(s,{autoIncrement:!0})},r.onsuccess=()=>{let a=r.result;if(this.#b=a,this.#d=s,a.objectStoreNames.contains(s))e(a);else{a.close();let n=indexedDB.open(this.#a,a.version+1);n.onupgradeneeded=e=>{let t=e.target.result;t.createObjectStore(s,{autoIncrement:!0})},n.onsuccess=()=>{this.#b=n.result,this.#d=s,e(this.#b)},n.onerror=t}},r.onerror=t}))}async #g(a,n,o,l){return new Promise((e,t)=>{let r=a.transaction(n,"readwrite").objectStore(n),s="auto"===o||null==o||""===o?r.add(l):r.put(l,o);s.onsuccess=()=>e(s.result),s.onerror=t})}async #h(i,c,u){return new Promise((e,t)=>{let r=i.transaction(c).objectStore(c),s=r.get(u);s.onsuccess=()=>{let t=s.result;void 0!==t?e(t):e(void 0)},s.onerror=t})}async #j(h,b){return new Promise((e,t)=>{let r=h.transaction(b).objectStore(b),s=[],a=r.openCursor();a.onsuccess=t=>{let r=t.target.result;r?(s.push({key:r.key,value:r.value}),r.continue()):e(s)},a.onerror=t})}async #i(d,p,w){return new Promise((e,t)=>{let r=d.transaction(p,"readwrite").objectStore(p),s=r.delete(w);s.onsuccess=()=>e(!0),s.onerror=t})}async #k(y,f){return new Promise((e,t)=>{let r=y.transaction(f,"readwrite").objectStore(f),s=r.clear();s.onsuccess=()=>e(!0),s.onerror=t})}use(e){return{set:async(t,r)=>{let s=await this.#e(e);return s.set(t,r)},get:async t=>{let r=await this.#e(e);return r.get(t)},delete:async t=>{let r=await this.#e(e);return r.delete(t)},getAll:async()=>{let t=await this.#e(e);return t.getAll()},clear:async()=>{let t=await this.#e(e);return t.clear()}}}async drop(e){return this.#b||await this.#f(e),this.#b.close(),new Promise((t,r)=>{let s=indexedDB.open(this.#a,this.#b.version+1);s.onupgradeneeded=t=>{let r=t.target.result;r.objectStoreNames.contains(e)&&r.deleteObjectStore(e)},s.onsuccess=()=>{this.#b=s.result,this.#c.delete(e),t()},s.onerror=r})}async export(e){let{filename:t="db_backup",download:r=!0}=e??{},s={},a=indexedDB.open(this.#a),n=await new Promise((e,t)=>{a.onsuccess=()=>e(a.result),a.onerror=t}),o=Array.from(n.objectStoreNames);for(let l of o){let i=await new Promise((e,t)=>{let r=n.transaction(l,"readonly"),s=r.objectStore(l),a=[],o=s.openCursor();o.onsuccess=t=>{let r=t.target.result;r?(a.push({key:r.key,value:r.value}),r.continue()):e(a)},o.onerror=t}),c=await Promise.all(i.map(async({key:e,value:t})=>({key:e,value:await this.#l(t)})));s[l]=c}n.close();let u=JSON.stringify(s,null,2);if(r){let h=new Blob([u],{type:"application/json"}),b=document.createElement("a");b.href=URL.createObjectURL(h),b.download=t+".json",b.click(),setTimeout(()=>{URL.revokeObjectURL(b.href)},1e3);return}return u}async import(e){let t;try{t=JSON.parse(e)}catch(r){throw Error("Invalid JSON format")}for(let s in t){let a=await this.#f(s);await this.#k(a,s);let n=a.transaction(s,"readwrite"),o=n.objectStore(s);for(let{key:l,value:i}of t[s]){let c=await this.#m(i);o.put(c,l)}await new Promise((e,t)=>{n.oncomplete=e,n.onerror=t}),a.close(),this.#b=null}}async #m(m){if("string"==typeof m&&m.startsWith("__BLOB__:")){let B=m.replace("__BLOB__:","");return this.#n(B)}if(Array.isArray(m))return Promise.all(m.map(e=>this.#m(e)));if("object"==typeof m&&null!==m){let g={};for(let[j,S]of Object.entries(m))g[j]=await this.#m(S);return g}return m}#o(v){return v instanceof Blob}#p($){return new Promise((e,t)=>{let r=new FileReader;r.onloadend=()=>{e("__BLOB__:"+r.result)},r.onerror=t,r.readAsDataURL($)})}#n(T){let N=T.split(","),O=N[0].match(/:(.*?);/),A=O?O[1]:"",W=atob(N[1]),k=new Uint8Array(W.length);for(let D=0;D<W.length;D++)k[D]=W.charCodeAt(D);return new Blob([k],{type:A})}async #l(L){if(this.#o(L))return await this.#p(L);if(Array.isArray(L))return Promise.all(L.map(e=>this.#l(e)));if("object"==typeof L&&null!==L){let _={};for(let[I,C]of Object.entries(L))_[I]=await this.#l(C);return _}return L}}